/*eslint-disable */
import React, { Component } from 'react'

const NumeralFormatter = require('cleave.js/src/shortcuts/NumeralFormatter')
const DateFormatter = require('cleave.js/src/shortcuts/DateFormatter')
const PhoneFormatter = require('cleave.js/src/shortcuts/PhoneFormatter')
const CreditCardDetector = require('cleave.js/src/shortcuts/CreditCardDetector')
const Util = require('cleave.js/src/utils/Util')
const DefaultProperties = require('cleave.js/src/common/DefaultProperties')

class Cleave extends Component {
  constructor(props) {
    super(props)
    const {
      value,
      options,
      onKeyDown,
      onChange,
      onFocus,
      onBlur,
      onInit
    } = this.props

    this.registeredEvents = {
      onInit: onInit || Util.noop,
      onChange: onChange || Util.noop,
      onFocus: onFocus || Util.noop,
      onBlur: onBlur || Util.noop,
      onKeyDown: onKeyDown || Util.noop
    }

      ; (options || {}).initValue = value

    this.properties = DefaultProperties.assign({}, options)

    this.state = {
      value: this.properties.result
    }
  }
  componentDidMount() {
    this.init()
  }

  componentWillReceiveProps(nextProps) {
    const phoneRegionCode = (nextProps.options || {}).phoneRegionCode
    let newValue = nextProps.value

    if (newValue !== undefined) {
      newValue = newValue.toString()

      if (newValue !== this.properties.initValue) {
        this.properties.initValue = newValue
        this.onInput(newValue)
      }
    }

    // update phone region code
    if (
      phoneRegionCode &&
      phoneRegionCode !== this.properties.phoneRegionCode
    ) {
      this.properties.phoneRegionCode = phoneRegionCode
      this.initPhoneFormatter()
      this.onInput(this.properties.result)
    }
  }

  init = () => {
    const pps = this.properties

    // so no need for this lib at all
    if (
      !pps.numeral &&
      !pps.phone &&
      !pps.creditCard &&
      !pps.date &&
      (pps.blocksLength === 0 && !pps.prefix)
    ) {
      this.onInput(pps.initValue)
      this.registeredEvents.onInit(this)

      return
    }

    pps.maxLength = Util.getMaxLength(pps.blocks)

    this.isAndroid = Util.isAndroid()

    this.initPhoneFormatter()
    this.initDateFormatter()
    this.initNumeralFormatter()

    this.onInput(pps.initValue)

    this.registeredEvents.onInit(this)
  }

  initNumeralFormatter = () => {
    const pps = this.properties

    if (!pps.numeral) {
      return
    }

    pps.numeralFormatter = new NumeralFormatter(
      pps.numeralDecimalMark,
      pps.numeralIntegerScale,
      pps.numeralDecimalScale,
      pps.numeralThousandsGroupStyle,
      pps.numeralPositiveOnly,
      pps.delimiter
    )
  }

  initDateFormatter = () => {
    const pps = this.properties

    if (!pps.date) {
      return
    }

    pps.dateFormatter = new DateFormatter(pps.datePattern)
    pps.blocks = pps.dateFormatter.getBlocks()
    pps.blocksLength = pps.blocks.length
    pps.maxLength = Util.getMaxLength(pps.blocks)
  }

  initPhoneFormatter = () => {
    const pps = this.properties

    if (!pps.phone) {
      return
    }

    // Cleave.AsYouTypeFormatter should be provided by
    // external google closure lib
    try {
      pps.phoneFormatter = new PhoneFormatter(
        new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode),
        pps.delimiter
      )
    } catch (ex) {
      throw new Error('Please include phone-type-formatter.{country}.js lib')
    }
  }

  setRawValue = value => {
    const pps = this.properties

    value = value !== undefined && value !== null ? value.toString() : ''

    if (pps.numeral) {
      value = value.replace('.', pps.numeralDecimalMark)
    }

    TouchList.onChange({ target: { value } })
  }

  getRawValue = () => {
    const pps = this.properties
    let rawValue = pps.result

    if (pps.rawValueTrimPrefix) {
      rawValue = Util.getPrefixStrippedValue(
        rawValue,
        pps.prefix,
        pps.prefixLength
      )
    }

    if (pps.numeral) {
      rawValue = pps.numeralFormatter.getRawValue(rawValue)
    } else {
      rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters)
    }

    return rawValue
  }

  onInit = () => {
    return this
  }
  isDelimiter = (letter, delimiter, delimiters) => {
    // single delimiter
    if (delimiters.length === 0) {
      return letter === delimiter;
    }

    // multiple delimiters
    return delimiters.some(function (current) {
      if (letter === current) {
        return true;
      }
    });
  }
  onKeyDown = event => {
    const pps = this.properties
    let charCode = event.which || event.keyCode

    // hit backspace when last character is delimiter
    if (
      charCode === 8 &&
      this.isDelimiter(
        pps.result.slice(-pps.delimiterLength),
        pps.delimiter,
        pps.delimiters
      )
    ) {
      pps.backspace = true
    } else {
      pps.backspace = false
    }

    this.registeredEvents.onKeyDown(event)
  }

  onFocus = event => {
    const pps = this.properties

    event.target.rawValue = this.getRawValue()
    event.target.value = pps.result

    this.registeredEvents.onFocus(event)
  }

  onBlur = event => {
    const pps = this.properties

    event.target.rawValue = this.getRawValue()
    event.target.value = pps.result

    this.registeredEvents.onBlur(event)
  }

  onChange = event => {
    let owner = this,
      pps = owner.properties

    owner.onInput(event.target.value)

    event.target.rawValue = owner.getRawValue()
    event.target.value = pps.result

    owner.registeredEvents.onChange(event.target.value, event)
  }

  onInput = value => {
    const pps = this.properties
    const prev = pps.result

    // case 1: delete one more character "4"
    // 1234*| -> hit backspace -> 123|
    // case 2: last character is not delimiter which is:
    // 12|34* -> hit backspace -> 1|34*

    if (
      !pps.numeral &&
      pps.backspace &&
      !this.isDelimiter(
        value.slice(-pps.delimiterLength),
        pps.delimiter,
        pps.delimiters
      )
    ) {
      value = Util.headStr(value, value.length - pps.delimiterLength)
    }

    // phone formatter
    if (pps.phone) {
      pps.result = pps.phoneFormatter.format(value)
      this.updateValueState()

      return
    }

    // numeral formatter
    if (pps.numeral) {
      pps.result = pps.prefix + pps.numeralFormatter.format(value)
      this.updateValueState()

      return
    }

    // date
    if (pps.date) {
      value = pps.dateFormatter.getValidatedDate(value)
    }

    // strip delimiters
    value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters)

    // strip prefix
    value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength)

    // strip non-numeric characters
    value = pps.numericOnly ? Util.strip(value, /[^\d]/g) : value

    // convert case
    value = pps.uppercase ? value.toUpperCase() : value
    value = pps.lowercase ? value.toLowerCase() : value

    // prefix
    if (pps.prefix) {
      value = pps.prefix + value

      // no blocks specified, no need to do formatting
      if (pps.blocksLength === 0) {
        pps.result = value
        this.updateValueState()

        return
      }
    }

    // update credit card props
    if (pps.creditCard) {
      this.updateCreditCardPropsByValue(value)
    }

    // strip over length characters
    value = pps.maxLength > 0 ? Util.headStr(value, pps.maxLength) : value

    // apply blocks
    pps.result = Util.getFormattedValue(
      value,
      pps.blocks,
      pps.blocksLength,
      pps.delimiter,
      pps.delimiters
    )

    // nothing changed
    // prevent update value to avoid caret position change
    if (prev === pps.result && prev !== pps.prefix) {
      return
    }

    this.updateValueState()
  }

  _handleOnFocusOut = event => {
    const { onFocusOut, name } = this.props
    const valueFromEvent = event.target.value

    if (onFocusOut) {
      onFocusOut(valueFromEvent, name, event)
    }
  }

  updateCreditCardPropsByValue = value => {
    const pps = this.properties
    let creditCardInfo

    // At least one of the first 4 characters has changed
    if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {
      return
    }

    creditCardInfo = CreditCardDetector.getInfo(value, pps.creditCardStrictMode)

    pps.blocks = creditCardInfo.blocks
    pps.blocksLength = pps.blocks.length
    pps.maxLength = Util.getMaxLength(pps.blocks)

    // credit card type changed
    if (pps.creditCardType !== creditCardInfo.type) {
      pps.creditCardType = creditCardInfo.type

      pps.onCreditCardTypeChanged.call(this, pps.creditCardType)
    }
  }

  updateValueState = () => {
    if (this.isAndroid) {
      window.setTimeout(() => {
        this.setState({ value: this.properties.result })
      }, 1)

      return
    }

    this.setState({ value: this.properties.result })
  }

  render() {
    const {
      value,
      options,
      onKeyDown,
      onFocus,
      onBlur,
      onChange,
      onInit,
      htmlRef,
      onCreditCardTypeChanged,
      ...propsToTransfer
    } = this.props

    return (
      <input
        type="text"
        ref={htmlRef}
        value={this.state.value}
        onKeyDown={this.onKeyDown}
        onChange={this.onChange}
        onFocus={this.onFocus}
        onBlur={this.onBlur}
        {...propsToTransfer}
        onFocusOut={this._handleOnFocusOut}
        data-cleave-ignore={[
          value,
          options,
          onFocus,
          onBlur,
          onKeyDown,
          onChange,
          onInit,
          htmlRef
        ]}
      />
    )
  }
}

export default Cleave
